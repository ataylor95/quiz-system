\chapter{Evaluation}
\section{Story/ requirements comparison}
For the final list of stories see appendix \ref{appendix:final-stories}. When looking at the final application and the final stories, they can all be argued as being completed with the exception of stories 7, 9 and 12. 

Concerning story 7, whilst technically the application only supports up to a hundred users simulataneously, this is not throttled by the application. But instead is due to the WebSockets provider Pusher, which for free use is limited at a hundred users. If the system were to go live, then this would be replaced by using an in house Redis server, or by paying Pusher for more slots. These would be able to meet this upper capacity and therefore meet the story. For story 9, a percentage of answers was decided to be too hard to do without relying too much on the WebSocket server being used, which as mentioned above could be changed therefore a simpler solution was added, just giving the number of answers submitted. This number would give a rough estimate of the percentage, as if the lecturer knew the class size, they could compare it to the number answered. It was important to not rely on Pusher and instead offer an alternative solution that did not quite meet the story.

As for the final story that was not completed, 12, the downloading of stories was done in the last iteration. It was decided that the reuploading of these to view on the application would have taken too long given how much other work was yet to be completed. Additionally, due to the download being a csv rather than the other potential format (XML), if the lecturer wished to view the results in a more graphical view, their preffered spreadsheet can easily be used to create graphs of the data. Whilst this is more work for the lecturer, it seemed like a minor issue and one worth causing if it meant more time for writing the report.

Of course, there were significant difference between the initial list of stories, \ref{appendix:initial-stories}, and the final list. A couple of new ones were added, such as number 14 and 15 on the final list. However, all the stories for part two were changed. The reasons for these changes have already been explained but it is obviously different from the initial set of stories. However, the redesign and production of new stories fills the same functionality as originally specified and therefore it can be argued that the original specifications are still met.

\section{Methodology}
I am very happy with the the methodology used. XP's main strength is its adaptability and the first thing to do was adapt a set its practices to fit the needs of the project. This was very beneficial as some practices were not relevant and would have not worked or even hindered the development. As development progressed, some of the practices had to be further adapted, such as dropping test driven development, allowing even more flexibility to the way I worked.

I particularly liked working to stories and in iterations. The iterations allowed small bits of working functionality to be written on a weekly basis. They were particularly useful in that they enforced small bits of design, implementation and testing each week, meaning there was a good mix of things to do. But most importantly, the iterations helped adapt to change. The best example is the part two redesign, which was originally planned to include a lot of work, two or three iterations worth, but instead came down to less than a full iteration of work. The iteration also included the creation of a review document at the end. This was used to evaluate the work done and the methodology itself, such as deciding that TDD should be dropped.

There were some problems though, the design and testing sections sometimes suffered within the iterations. This was because I was more interesting in getting the implementation done. Its not to say that design and testing didn't happen when they were supposed to, its just that occasionally it had to be done the following iteration.

Another major problem is that due to a lack of overall design at the start, as encouraged by the use of XP, there was some redesigning and reimplementation happening throughout due to some bad or short sighted design choices. A good example would be when the position was added to the questions, whilst quite an important part of the implementation, it was not in the original designs at all. Storing this position in the question and session tables and using those both to find the right question could have instead used a seperate table to store the position and a reference to the relevant question. This would have put less work on the database and required less coding. Another example of where upfront design might have worked is the QuizController is quite large and some of functionality could be split into sub controllers or split better amounf existing ones.

Its problems like these that could have been avoided if the system had been designed from the ground up. An upfront design might also fix what sometimes feels like lots of small bits of functionality tied together into something that feels more cohesive. On the flip side though, it might have caused there to be too much work, for example without the iterations, part two might have been designed in a way similar to the original proposals which appeared to be a lot of work.

Whilst not really a part of the methodology, the time spent refactoring and documenting the code really helped. As mentioned above, some stories built ontop of old ones, and some of the implementations changed a lot. Without the time spent documenting and refactoring the functions the code base would have been impossible to navigate and modify. Just writing the PHPDoc for function calls helped tremendously when doing any future work.

\section{Tools and technologies}
A number of tools and technologies were used during development and overall I am happy with the majority. Using PHP and Laravel seemed to fit the project very well as there were no features that were impossible to do in the language or framework. Not all parts of the framework were great however, the testing framework, Dusk, was particularly troublesome. This was mainly due to how new Dusk is, however the problems slowed work quite a lot. There was no easy alternative for application tests however, so Dusk was probably still the best choice. And over time, the framework will hopefull iron out its problems so for future work will probably be in a much better state. 

The JavaScript side of things could probably have been handled better, I never got all the JS into a single minified file like you are supposed to with Laravel. This meant that it was a little disorganised and sometimes hard to navigate and change things. It probably would have been better to spend some more time figuring out how to get it all into JS files rather than as script tags, however I deemed it not a high priority to better focus on getting the system working.

As for things that I would not change, WebSockets is an easy one. They were easy to set up, did exactly what was needed without the need for any strange behaviour, such as forcing a page refresh and are relatively future proof due to being such a new standard. Most of the tools I used I had no problem with and would also use without hesitation a second time. Git was very important and whilst I did not need to use it for much version control, it gave me the option should it ever arise. My diary and Trello however were very important in day to day development. They were used to keep track of all progress in the project and also to try and plan some of the upcoming work. Without them, the project would have been much tougher and I am happy with the way I used them.

Other tools I am happy with include the Chrome developer tools which I used for debugging a lot and my editor, Vim. A program that could potentially have replaced both of these is an editor called PhpStorm \cite{phpstorm}. As an editor it filled Vims role but it also provides a number of other features like a debugger. Debuggers for PHP are quite unusual as the code is executed by the server and not locally meaning debugging is usually manual with a lot of "die()" commands being used to figure out what is wrong. This is clearly not the best as a good debugger can speed up finding problems very easily. PhpStorm also comes with a live preview feature, this can be debugged and edited in much the same way the Chrome dev tools are used. I did not however use it because I thought that overall the lack of a debugger and other features did not slow me down enough to warrant getting and learning a new piece of software.

\section{User testing evaluation}
As discussed in the Testing chapter, the results were overall positive, with the majority of users and the lecturer having a good experience with the system. There were a number of issues and possible improvements raised, though none of them need rectifying immediately. I am a little dissapointed in not having much feedback on the mobile side of things. Hopefully the one user with an issue was an outlier and from my experience of the system on phones when developing it, it was working.

\section{Things to do differently and future work}
There are a number of design choice that could have been done differently in retrospect. I think the main one is a different way to track the positions of slides and questions. It was desgined initially without much thought to how it was going to work further down the line, leading to a bit of a strange system. As mentioned before, using a reference table for keeping track of positions may have been a good choice for this.

The other main thing that could have changed was the use of testing. When TDD failed, a possible replacement that I did not look into at the time was Behaviour Driven Development\cite{bdd}. BDD is generally used to explain the behaviour of the application in regards to the story, and then used to evaluate the outcome based on the expected outcome. Whilst BDD and TDD could have been used together, BDD can itself be used alone. It also would have suited the development process followed in this project, as the stories were worked on in a roughly one by one basis and the Dusk tests are a form of application tests. The way that BDD would evaluate the story would involve application tests. It would have fit in quite nicely but it never got suggested and might have taken some times to set up.

The last major change would probably be to the way a lot of the models are used, on the whole almost all model functionality is static. The main reason for this is that the majority of functions in the models update the database or retrieve small bits of information from the tables or only needed to be called once in the process so there was no point in instantiating so many objects. There is object orientation in the controllers however there could have been a lot more within the models. A lot of the position changing functionality could work very well if done as an object parameter and then saved at the end. Currently the position variable is retrieved from the database and passed around a lot rather than used as an object paramter. Another reason a lot of the later potential non static functions were building on the already written static functions so it was easier just to add more static functions than refactor the whole system. From my perspective I would have preffered more object orientated programming in the application however it was far easier to just keep writing the static functions.

As for future work there are a number of potential tasks. The most pressing would undoubtedly be moving the WebSocket host from Pusher to Redis or something similar. This would be an important first task as it raises the limit on number of users without costing anything. An extension that may be quite important for the system would be to integrate the university login system, which I believe uses Lightweight Directory Access Protocol, LDAP. This would mean lecturers would have accounts linked to their uni accounts and would potentially allow the use of SSO. In general the user authorisation could be imporved substantially. All lecturers can see all the other lecturers quizzes and questions, and do anything to them. Limiting their actions was not a part of the original set of stories and therefore the authentication and authorisation is very basic. More authorisation should realistically be added to the system.

There are also a number of smaller things that could be added with little development time, such as adding more question types or adding some keyboard commands for the quiz controls allowing the lecturer to press enter for the next slide.

\section{Summary}
Overall, I am happy with the project, I think there are a lot of different ways it could have been implemented which might have been better now that I know how to do it. There are also a number of potential improvements and extensions that could be developed but the final application meets the majority of its requirements and the user feedback was good which is very positive.