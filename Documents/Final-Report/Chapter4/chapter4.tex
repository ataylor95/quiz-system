\chapter{Testing}

\section{Overview}
At the start of the project, testing was to use two practices from Agile. These were Test Driven Development and Continuous Integration. Whilst these two practices both failed due to a mixture of reasons as described in the Iterations chapter, testing was still performed within each iteration. Rather than go over the tests made each week within the previous chapter, this section will summarise the tests. Overall there were x tests (TODO: fill in) that test the overall functionality of the system. Unit tests were dropped for a number of reasons in favour of application tests (TODO: why? take from iter docs).

\section{Application testing}
TODO: screenshot final output of tests, possible one running for appendices. Also could list all tests somewhere.
To do application tests, a testing framework called Laravel Dusk (TODO cite https://mattstauffer.co/blog/introducing-laravel-dusk-new-in-laravel-5-4) was used, which is the default testing framework provided with Laravel 5.4. It runs the tests within a Chrome instance by running a standalone server which then calls the Chrome application installed on the machine that the tests are being run on. The advantages of running tests like this rather than say executing PHP ont he server and reading a virtual DOM is that this allows JavaScript on the page to be evaluated and executed. JavaScript is vital to many of the components of the application so if it was not usable within tests, many parts of the system would have to be ignored within the tests.

These tests test the application as whole, rather than individual bits of code. This allows the tests to be written with the original requirements, the stories, in mind and so makes these tests a good way to evaluate the application at the end of its development. Tests were organised by story, as these provided an area of the application that needed to be checked, which makes them more human readable for any future development.

Tests use a test database rather than the production one to ensure the integrity of data on the production system. This test database is left intentionally empty when, with each test performing a migration for the test. Within each test the database is populated with relevant data using a number of database factories. These factories allow the easy and quick creation of any data needed within the test, though using a normal Model to input data would also still work. At the end of each test, the database is rolled back for the next test to run, leaving an empty db for a new migration and data.

Database transactions could have been used instead, which use a pre migrated database and then any data input during each test is deleted at the end of the test. Whilst the test db could be migrated before any tests were run to allow the use of transactions, this would mean than any future changes to the migration files would mean that the developer would have to remember to remigrate the test database as well. Doing a migration for every test might be somewhat resource intensive, but it allows the tests to be written and run completely standalone from each other with no need to tie into any earlier setup functions. 

\section{Security testing}
One story specifically concerns security: Users should not be able to submit their own answers by altering the HTML, as they did with Qwizom. The tests for this however are not that easy to do within the confines of Dusk due to the nature of the framework. The framework is concerned with user facing application tests and has no ability to change the DOM of the page or send custom POST requests to the server. This means that this story is better tested in the User testing section.

Other aspects of security can be checked however, being a web application there are a number of well known attack types including SQL injection, cross site scripting and cross site request forgery attacks. These are tested in (TODO: add these)

\section{User testing}
TODO

\section{Stress testing}
Though there are a number of tools out there to do exactly that, there was no time to set up and any official stress testing. However, the user tests within the lecture helped a give a good idea of the stress the system could take. Like many sites though, the application was mostly restricted by its server setup rather than by its design. (TODO: prove after user testing)

\section{Automated testing}
TODO: remove this section?
Whilst CI was abandoned early on into the development of the application, the Dusk tests are easy to run and automatically execute within a browser if the appropriate browser drivers are available. This means that it should not be too hard to integrate these tests into a CI tool if required in any future development.


Stuff to talk about:
comprehensiveness of testing incl bdd and cucumber etc
edge cases? how did we manage those (user and application)
