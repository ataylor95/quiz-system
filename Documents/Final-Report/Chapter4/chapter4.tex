\chapter{Testing}

\section{Overview}
At the start of the project, testing was to use two practices from Agile. These were Test Driven Development and Continuous Integration (CI). Whilst these two practices both failed due to a mixture of reasons as described in the Iterations chapter, testing was still performed within each iteration. Rather than go over the tests made each week within the previous chapter, this section will summarise the tests. Overall there were x tests (TODO: fill in once development finished) that test the overall functionality of the system. Unit tests were dropped for a number of reasons in favour of application tests.

Unit testing suits a situation where more of the base code is written by the developer, in this case the majority of the code is built on a pretested framework. Testing the final implementation would fit better than trying to test if a view is rendered by a controller correctly. Application tests can also be used to test the stories, meaning that they can give a much clearer indication of whether a story is complete and whether the customer will be happy.

Unit testing also takes up a lot of time if done as well as application testing which would have affected the final product and dropping it was a necessary exchange to save development time.

\section{Application testing}
TODO: screenshot final output of all tests. Also could list all tests somewhere in appendix?
To do application tests, a testing framework called Laravel Dusk was used, which is the default testing framework provided with Laravel 5.4\cite{dusk}\cite{dusk-desc}. It runs the tests within a Chrome instance by running a standalone server which then calls the Chrome application installed on the machine that the tests are being run on. The advantages of running tests like this rather than say executing PHP on the server and reading a virtual DOM is that this allows JavaScript on the page to be evaluated and executed. JavaScript is vital to many of the components of the application so if it was not usable within tests, many parts of the system would have to be ignored within the tests.

These tests test the application as whole, rather than individual bits of code. This allows the tests to be written with the original requirements, the stories, in mind and so makes these tests a good way to evaluate the application at the end of its development. Tests were organised by story, as these provided an area of the application that needed to be checked, which makes them more human readable for any future development.

Tests use a test database rather than the production one to ensure the integrity of data on the production system. This test database is left intentionally empty when, with each test performing a migration for the test. Within each test the database is populated with relevant data using a number of database factories. These factories allow the easy and quick creation of any data needed within the test, though using a normal Model to input data would also still work. At the end of each test, the database is rolled back for the next test to run, leaving an empty database for a new migration and data.

Database transactions could have been used instead, which use a pre migrated database and then any data input during each test is deleted at the end of the test. Whilst the test db could be migrated before any tests were run to allow the use of transactions, this would mean than any future changes to the migration files would mean that the developer would have to remember to re-migrate the test database as well. Doing a migration for every test might be somewhat resource intensive, but it allows the tests to be written and run completely standalone from each other with no need to tie into any earlier setup functions. 

\subsection{Limitations of dusk}
Various problems
Also cucumber or something?
Dusk cant do WebSockets for some reason, assume blocking communication?
Dusk cannot see inside Canvas tags
Dusk selectors are rubbish, sometimes by text, sometimes id but never returns a collection, always the first item it sees
Lots of code repetition for moi
Pauses

\section{Security testing}
One story specifically concerns security: Users should not be able to submit their own answers by altering the HTML, as they did with Qwizdom. The tests for this however are not that easy to do within the confines of Dusk due to the nature of the framework. The framework is concerned with user facing application tests and has no ability to change the DOM of the page or send custom POST requests to the server. This means that this story is better tested in the user testing section.

Other aspects of security can be checked however, being a web application there are a number of well known attack types including SQL injection, cross site scripting (XSS) and cross site request forgery (CSRF) attacks. These tests are located in SecurityTest.php. There are five tests that test both SQL Injection and XSS attacks. SQL injection attacks involves attackers trying to execute their own SQL code on the server, thereby giving them access to the system or to try and damage the system by say dropping some tables. XSS attacks are when attackers attempt to inject thier own JavaScript into the system that may be run on another users page. Typically this would include injecting a script tag with malicioud code into the database that would then be executed when written to the page by another user viewing a page. (TODO: cite these?) 

For the SQL injection tests, a string that tries to insert a new database extry is used:
\begin{verbatim}
	"INSERT INTO `quizzes` 
		(`name`, `desc`, `user_id`, `created_at`, `updated_at`) 
		VALUES ('SQL Injection', 'this is an attack', '1', now(), now());"
\end{verbatim}
And for the XSS attacks it tries to add a script tag with an alert:
\begin{verbatim}
	<script>alert('hey xss');</script>
\end{verbatim} 

There are two main places that these attacks can be carried out. The first is on the front page, the session search field could be used to insert malicious data. Though nothing is saved from this input, it does query the database, which means it could be subject to an SQL injection attack. If the search returned the original search query, then it could be used to embed some javascript, and if the search was then linkable (i.e. in the URL parameters), it could be sent on to other users. The other place that these two attacks can be carried out are on the admin area, in the quiz and quetion creation pages where SQL or XSS code could be added to the body of the various quiz and question fields.

For SQL injection attacks, the easiest way to check that this data has not been added is to look for the record in the quizzes table. With the XSS attack, the page source can be searched for the script tag. Laravel copes with these attacks by default by escaping the inputs\cite{laravel-web-attacks}. With SQL, the entire string is quoted and not seen as an actual SQL command. With the XSS the HTML tags are escaped in a similar fashion, the \textless and \textgreater symbols are turned into \&lt; and \&gt; which are not rendered as HTML when written to the page.

The tests prove that the system works as intended and these two attack types are not possible. Cross site request forgery attacks are another form of attack but harder to test as they rely on the browsers weaknesses and come from another website. Dusk cannot simulate this sort of environment. However, for forms to be submitted within the system a CSRF token has to be submitted with the form. This token is compared to the user session to ensure they are the ones submitting this data, not a third party site. Laravel forces forms to contain this token, ensuring this attack cannot take place. 

\section{User testing}
TODO

\section{Stress testing}
Though there are a number of tools out there to do exactly that, there was no time to set up and any official stress testing. However, the user tests within the lecture helped a give a good idea of the stress the system could take. Like many sites though, the application was mostly restricted by its server setup rather than by its design. (TODO: prove after user testing)

\section{Automated testing}
Whilst CI was abandoned early on into the development of the application, the Dusk tests are easy to run and automatically execute within a browser if the appropriate browser drivers are available. This means that it should not be too hard to integrate these tests into a CI tool if required in any future development.


TODO: Stuff to talk about:

comprehensiveness of testing incl potential of using bdd and cucumber in future

edge cases? how did we manage those = (user and application)